Pegex::Parser
=============

Pegex Parser Runtime

= Synopsis

  use Pegex::Parser;
  use SomeGrammarClass;
  use SomeReceiverClass;

  my $parser = Pegex::Parser->new(
      grammar => SomeGrammarClass->new,
      receiver => SomeReceiverClass->new,
  );

  my $result = $parser->parse($SomeInputText);

= Description

Pegex::Parser is the Pegex component that provides the parsing engine runtime.
It requires a Grammar object and a Receiver object. It's `parse()` method
takes an input that is expected to be matched by the grammar, and applies the
grammar rules to the input. As the grammar is applied, the receiver is
notified of matches. The receiver is free to do whatever it wishes, but often
times it builds the data into a structure that is commonly known as a Parse
Tree.

When the parse method is complete it returns whatever object the receiver has
provided as the final result. If the grammar fails to match the input along
the way, the parse method will throw an error with much information about the
failure.

= The `parse()` Method

The parse method takes one of the following 4 forms:

- `$parser->parse($input)`

  The most common form is to provide an input string to parse. You may also use
  a Pegex::Input object instead of a string.

- `$parser->parse($input, $options)`

  You may also specify a hash reference of options. See the following "Options"
  section for deatils.

- `$parser->parse()`

  With no arguments, the parser will continue parsing from the previous call to
  `parse()`. This only makes sense if the `partial` option was used.

- `$parser->parse($input, $start)`

  This usage is deprecated. Use the `start` option instead.

  (Use the named starting rule to perform the parse.)

== Options for `parse()`

If the options hash reference is specified, the following options are
supported:

- `start`

  String. The name of the starting rule to use when starting a parse. By
  default, Pegex with start with the first rule in the grammar, or the rule
  named `TOP`, if provided.

- `return`

  Boolean. By default, Pegex::Parser will throw an error when a parse fails. If
  `return` is set to true, then the `parse()` method will return a false value
  on failure. The `->error` method can be called to get the actual error.

- `partial`

  Boolean. By default, a grammar must match all of its input. Setting this to
  true allows for a partial match. The `completed` method can be used to check
  if the end of the input has been matched.

= Other API methods

- `completed`

  Check if a parse operation has completed.

= Constructor

The Pegex::Parser `new` object constructor takes these attributes:

- `grammar`

  A Pegex::Grammar object. Required.

- `receiver`

  A Pegex::Receiver object.

- `debug`

  Boolean. Turn on debugging. Default false.

- `recursion_limit`

  Integer. Recursion level to terminate on. Default 0 (off).

- `recursion_warn_limit`

  Integer. Recursion level to warn on. Default 0 (off).

- `iteration_limit`

  Integer. Number of matches to try before terminating. Default 0 (off).

= Debugging

Pegex::Parser currently has 4 settings that are useful for debugging. These
can be set as Pegex::Parser object attributes, global variables or environment
variables:

- `debug` or `$Pegex::Parser::Debug` or `$ENV{PERL_PEGEX_DEBUG}`

  If set to a true value, it enables very useful trace messages for every
  internal match operation.

- `recursion_limit` or `Pegex::Parser::RecursionLimit` or `$ENV{PERL_PEGEX_RECURSION_LIMIT}`

  If set to a number greater than 0, Pegex::Parser will terminate after that
  recursion level number is reached.

- `recursion_warn_limit` or `Pegex::Parser::RecursionWarnLimit` or `$ENV{PERL_PEGEX_RECURSION_WARN_LIMIT}`

  If set to a number greater than 0, Pegex::Parser will issue a warning every
  time that recursion level number is reached.

- `iteration_limit` or `Pegex::Parser::IterationLimit` or `$ENV{PERL_PEGEX_ITERATION_LIMIT}`

  If set to a number greater than 0, Pegex::Parser will terminate after that
  number of matches has been attempted.

- `debug_indent` or `$Pegex::Parser::DebugIndent` or `$ENV{PERL_PEGEX_DEBUG_INDENT}`

  Tells the parser how many spaces should be used for indenting debugging
  output. Default is 1.

- `debug_color` or `$Pegex::Parser::DebugColor` or `$ENV{PERL_PEGEX_DEBUG_COLOR}`

  If enabled, it will color `got` and `not` events in the debugging output
  (`bright_green` and `bright_red` respectively). Color will be enabled by
  default for debugging. It requires [Term::ANSIColor].

  - `always` or `1`

    Color is enabled.

  - `auto`

    Color is enabled when STDERR is a tty.

  - `never` or 0

    Color is disabled.

  You can configure the specific colors used by appending them like this:

    PERL_PEGEX_DEBUG_COLOR='always, cyan bold, black on_yellow'

  For available colors, see [Term::ANSIColor]

Note: Using these variables incurs a slight performance hit, but if you don't
use them all the debugging code is optimized away.

= See Also

* [Pegex::Grammar]
* [Pegex::Receiver]

<<<cpan-tail>>>
